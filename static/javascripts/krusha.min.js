if (!Array.prototype.find) {
    Array.prototype.find = function(predicate) {
        if (this == null) {
            throw new TypeError("Array.prototype.find called on null or undefined");
        }
        if (typeof predicate !== "function") {
            throw new TypeError("predicate must be a function");
        }
        var list = Object(this);
        var length = list.length >>> 0;
        var thisArg = arguments[1];
        var value;
        for (var i = 0; i < length; i++) {
            value = list[i];
            if (predicate.call(thisArg, value, i, list)) {
                return value;
            }
        }
        return undefined;
    };
}

if (!Array.prototype.findIndex) {
    Array.prototype.findIndex = function(predicate) {
        if (this == null) {
            throw new TypeError("Array.prototype.find called on null or undefined");
        }
        if (typeof predicate !== "function") {
            throw new TypeError("predicate must be a function");
        }
        var list = Object(this);
        var length = list.length >>> 0;
        var thisArg = arguments[1];
        var value;
        for (var i = 0; i < length; i++) {
            value = list[i];
            if (predicate.call(thisArg, value, i, list)) {
                return i;
            }
        }
        return -1;
    };
}

var onloadCallback = function() {
    grecaptcha.render("recaptcha", {
        sitekey: ""
    });
};

var krusha = angular.module("krushaTV", [ "ngRoute", "ngAnimate", "ngCookies", "ngSanitize", "ui.bootstrap", "growlNotifications", "ngClipboard" ]);

krusha.config([ "$routeProvider", "$httpProvider", "$compileProvider", "$locationProvider", "$tooltipProvider", "ngClipProvider", function($routeProvider, $httpProvider, $compileProvider, $locationProvider, $tooltipProvider, ngClipProvider) {
    $routeProvider.when("/", {
        templateUrl: "/static/templates/today.html",
        controller: "todayCtrl"
    }).when("/search", {
        templateUrl: "/static/templates/search.html",
        controller: "searchCtrl"
    }).when("/show/:id", {
        templateUrl: "/static/templates/show.html",
        controller: "showCtrl"
    }).when("/login", {
        templateUrl: "/static/templates/login.html",
        controller: "loginCtrl"
    }).when("/signup", {
        templateUrl: "/static/templates/signup.html",
        controller: "signupCtrl"
    }).when("/track", {
        templateUrl: "/static/templates/track.html",
        controller: "trackCtrl"
    }).when("/admin/reddit", {
        templateUrl: "/static/templates/admin/reddit.html",
        controller: "redditCtrl"
    }).when("/admin/imdb", {
        templateUrl: "/static/templates/admin/imdb.html",
        controller: "imdbCtrl"
    }).when("/profile", {
        templateUrl: "/static/templates/profile.html",
        controller: "profileCtrl"
    }).when("/unwatched", {
        templateUrl: "/static/templates/unwatched.html",
        controller: "unwatchedCtrl"
    }).when("/watched", {
        templateUrl: "/static/templates/watched.html",
        controller: "watchedCtrl"
    }).otherwise({
        redirectTo: "/"
    });
    $httpProvider.interceptors.push("interceptor");
    $compileProvider.debugInfoEnabled(true);
    $locationProvider.html5Mode(true);
    $tooltipProvider.setTriggers({
        slideStartEvent: "slideStopEvent"
    });
    ngClipProvider.setPath("/static/javascripts/bower_components/zeroclipboard/dist/ZeroClipboard.swf");
} ]);

krusha.controller("navCtrl", [ function() {} ]);

krusha.controller("parentCtrl", [ "$scope", function($scope) {
    $scope.title = "";
} ]);

krusha.filter("orderByName", [ "$filter", function($filter) {
    var remove_the_regex = /(?:^the )?(.*)/i;
    var save_sort_by = "name";
    var remove_the = function(show) {
        return show[save_sort_by].match(remove_the_regex)[1];
    };
    return function(shows, sort_by) {
        save_sort_by = typeof sort_by !== "undefined" ? sort_by : "name";
        return $filter("orderBy")(shows, remove_the);
    };
} ]);

krusha.filter("formatEpisode", function() {
    var zeroPadding = function(n) {
        n = parseInt(n);
        if (n < 10) {
            return "0" + n.toString();
        } else {
            return n.toString();
        }
    };
    return function(episode, season) {
        episode = zeroPadding(episode);
        season = zeroPadding(season);
        return "S" + season + "E" + episode;
    };
});

krusha.filter("copyEpisode", [ "$filter", function($filter) {
    return function(episode) {
        return episode.showname + " " + $filter("formatEpisode")(episode.episode, episode.season);
    };
} ]);

krusha.filter("countUnwatched", function() {
    var countUnwatched = function(show) {
        return !!show.find(function(season) {
            if (season.episodes.find(function(episode) {
                return episode.watched === false;
            })) {
                return true;
            }
        });
    };
    return function(show, showWatched) {
        return showWatched ? true : countUnwatched(show);
    };
});

var reddit_regex = /^(?:http(?:s)?:\/\/)?(?:www\.)?(?:reddit\.com)?(\/r\/\w+)(?:[.?&/].*)?$/i;

var imdb_regex = /^(?:https?:\/\/)?(?:www.)?(?:imdb.com\/title\/)?(tt\d{7})(?:\/.*)?$/i;

krusha.directive("subreddit", function() {
    return {
        require: "ngModel",
        link: function(scope, elm, attrs, ctrl) {
            ctrl.$validators.subreddit = function(modelValue, viewValue) {
                if (ctrl.$isEmpty(modelValue)) {
                    return true;
                }
                if (reddit_regex.test(viewValue)) {
                    return true;
                }
                return false;
            };
        }
    };
});

krusha.directive("imdb", function() {
    return {
        require: "ngModel",
        link: function(scope, elm, attrs, ctrl) {
            ctrl.$validators.imdb = function(modelValue, viewValue) {
                if (ctrl.$isEmpty(modelValue)) {
                    return true;
                }
                if (imdb_regex.test(viewValue)) {
                    return true;
                }
                return false;
            };
        }
    };
});

krusha.directive("dailyepisodes", [ function() {
    return {
        restrict: "E",
        templateUrl: "/static/templates/directives/dailyepisodes.html",
        replace: true
    };
} ]);

krusha.directive("genreLabels", [ function() {
    var link = function($scope, element, attrs) {
        var unwatch = $scope.$watch(attrs.genres, function(value) {
            if (typeof value !== "undefined") {
                $scope.genres = value.split(", ");
                unwatch();
            }
        });
    };
    return {
        restrict: "E",
        link: link,
        template: '<span class="label label-default" ng-repeat="genre in ::genres">{{ ::genre }}</span>'
    };
} ]);

krusha.directive("loadingspinner", [ "$http", function($http) {
    return {
        restrict: "E",
        link: function($scope, elm) {
            $scope.isLoading = function() {
                return $http.pendingRequests.length > 0;
            };
            $scope.$watch($scope.isLoading, function(v) {
                if (v) {
                    elm.show();
                } else {
                    elm.hide();
                }
            });
        },
        template: '<div class="spinner"><div class="bounce1"></div><div class="bounce2"></div><div class="bounce3"></div></div>'
    };
} ]);

krusha.directive("loadingcontent", [ "$http", function($http) {
    return {
        restrict: "A",
        link: function(scope, elm) {
            scope.isLoading = function() {
                return $http.pendingRequests.length > 0;
            };
            scope.$watch(scope.isLoading, function(v) {
                if (v) {
                    elm.hide();
                } else {
                    elm.show();
                }
            });
        }
    };
} ]);

var seasons_element = null;

var episodes_element = null;

function updateOffset() {
    var height_difference = episodes_element.outerHeight() - seasons_element.outerHeight();
    var scrollTop = $(this).scrollTop();
    if (height_difference < 0) {
        seasons_element.removeClass("seasons-static");
        seasons_element.removeClass("seasons-fixed");
        seasons_element.addClass("seasons-relative");
    } else if (scrollTop < height_difference) {
        seasons_element.addClass("seasons-fixed");
        seasons_element.removeClass("seasons-static");
        seasons_element.removeClass("seasons-relative");
    } else {
        seasons_element.addClass("seasons-static");
        seasons_element.removeClass("seasons-fixed");
        seasons_element.removeClass("seasons-relative");
    }
}

krusha.directive("scrollfix", [ function() {
    var link = function($scope, element) {
        seasons_element = element.find("#seasons").first();
        episodes_element = element.find("#episodes").first();
        var scroll_ok = true;
        var intervalID = setInterval(function() {
            scroll_ok = true;
        }, 17);
        var scrollfix = function() {
            if (scroll_ok === true) {
                scroll_ok = false;
                updateOffset();
            }
        };
        $(window).on("scroll", scrollfix);
        element.on("$destroy", function() {
            $(window).off("scroll", scrollfix);
            clearInterval(intervalID);
        });
    };
    return {
        restrict: "A",
        link: link
    };
} ]);

krusha.directive("slider", function($timeout) {
    var body = $("body");
    var link = function($scope, element) {
        var slideStart = false;
        var bar = element.find(".bar");
        var barWidth = null;
        var barPositionLeft = null;
        var barPositionRight = null;
        var handle = element.find(".handle");
        var handleWidth = null;
        function addListeners(element) {
            handle.bind("mousedown touchstart", startSlide);
        }
        function init() {
            if (bar.is(":visible")) {
                barWidth = bar.width();
                barPositionLeft = bar.offset().left;
                handleWidth = handle.width();
                barPositionRight = barPositionLeft + barWidth - handleWidth;
                $scope.$watch("model", function(model) {
                    if (!!slideStart) {
                        $timeout(function() {
                            handle.trigger("slideStartEvent");
                        });
                    }
                    var perc = (barWidth - handleWidth) / barWidth;
                    var step = (model - $scope.min) / ($scope.max - $scope.min) * 100 * perc;
                    handle.css("left", step + "%");
                });
            } else {
                $timeout(init, 100);
            }
        }
        function startSlide(event) {
            event.preventDefault();
            slideStart = true;
            $timeout(function() {
                handle.trigger("slideStartEvent");
            });
            handle.addClass("active");
            if (typeof $scope.onSlideStart !== "undefined") {
                $scope.onSlideStart();
            }
            body.bind("mouseup touchend", stopSlide);
            body.bind("mousemove", slideMouse);
            body.bind("touchmove", slideTouch);
        }
        function stopSlide(event) {
            event.preventDefault();
            slideStart = false;
            $timeout(function() {
                handle.trigger("slideStopEvent");
            });
            handle.removeClass("active");
            body.unbind("mouseup touchend", stopSlide);
            body.unbind("mousemove", slideMouse);
            body.unbind("touchmove", slideTouch);
            if (typeof $scope.onSlideStop !== "undefined") {
                $scope.onSlideStop();
            }
        }
        function slideMouse(event) {
            event.preventDefault();
            slide(event.pageX);
        }
        function slideTouch(event) {
            event.preventDefault();
            slide(event.originalEvent.touches[0].pageX);
        }
        function slide(pageX) {
            var diff = null;
            if (barPositionLeft > pageX) {
                diff = 0;
            } else if (barPositionRight < pageX) {
                diff = barWidth;
            } else {
                diff = pageX - barPositionLeft;
            }
            $scope.$apply(function() {
                var temp_model = parseInt($scope.min) + diff / barWidth * (parseInt($scope.max) - parseInt($scope.min));
                $scope.model = temp_model - temp_model % $scope.step;
            });
        }
        init();
        addListeners(element);
        if (typeof $scope.tooltipPlacement === "undefined") {
            $scope.tooltipPlacement = "top";
        }
    };
    return {
        restrict: "E",
        link: link,
        scope: {
            min: "@",
            max: "@",
            step: "@",
            model: "=ngModel",
            onSlideStart: "&",
            onSlideStop: "&",
            tooltipPlacement: "@"
        },
        template: '<div class="bar"><div class="handle" tooltip="{{ model }}" tooltip-placement="{{ ::tooltipPlacement }}" tooltip-trigger="slideStartEvent"></div></div>'
    };
});

krusha.directive("success", [ "$timeout", function($timeout) {
    var link = function($scope, element) {
        var timeout_promise = null;
        $scope.$watch("successHandler", function(newVal, oldVal) {
            if (newVal !== oldVal && newVal !== "not") {
                $timeout.cancel(timeout_promise);
                element.fadeIn(100);
                $scope.success = $scope.successHandler;
                $scope.successHandler = "not";
                timeout_promise = $timeout(function() {
                    element.fadeOut();
                }, $scope.timeout);
            }
        }, true);
    };
    return {
        restrict: "E",
        scope: {
            timeout: "@timeout",
            successHandler: "=success"
        },
        template: "<span ng-class=\"{'text-success fa fa-check': !!success, 'text-danger': !success}\">{{ success === false ? 'Error' : '' }}</span>",
        link: link
    };
} ]);

krusha.directive("unwatched", [ "$timeout", "loggedin", function($timeout, loggedin) {
    var link = function($scope) {
        if (typeof $scope.shows === "undefined") $scope.shows = [];
        if (typeof $scope.seasons === "undefined") $scope.seasons = [];
        $scope.dateFormat = loggedin.getDateFormat();
        $scope.getActiveShow = function() {
            return $scope.shows.find(function(show) {
                return !!show.active;
            });
        };
        $scope.scrollShows = function() {
            $(document.body).animate({
                scrollTop: $("#shows").offset().top - 70
            }, 200);
        };
        $scope.getActiveSeason = function() {
            return $scope.seasons.find(function(season) {
                return !!season.active;
            });
        };
        $scope.getSeasonsScroll = function(show_id) {
            $scope.getSeasons(show_id);
            $(document.body).animate({
                scrollTop: $("#seasons").offset().top - 70
            }, 200);
        };
        $scope.getEpisodesScroll = function(show_id, season) {
            $scope.getEpisodes(show_id, season);
            $(document.body).animate({
                scrollTop: $("#episodes").offset().top - 70
            }, 200);
        };
        $scope.watched_text = $scope.watched ? "unwatched" : "watched";
        $scope.watched_text_cap = $scope.watched ? "Unwatched" : "Watched";
        $scope.watched_text_cap_short = $scope.watched ? "Unw." : "W.";
    };
    return {
        restrict: "E",
        templateUrl: "/static/templates/directives/unwatched.html",
        link: link,
        scope: {
            shows: "=shows",
            seasons: "=seasons",
            episodes: "=episodes",
            getSeasons: "=getSeasons",
            getEpisodes: "=getEpisodes",
            markEpisodeWatched: "=markEpisodeWatched",
            markSeasonWatched: "=markSeasonWatched",
            markShowWatched: "=markShowWatched",
            watched: "=watched"
        }
    };
} ]);

krusha.service("search_text", [ function() {
    var search = null;
    return {
        getText: function() {
            return search;
        },
        setText: function(value) {
            search = value;
        }
    };
} ]);

krusha.factory("redirect", [ "$location", function($location) {
    var last_location = null;
    return {
        login: function() {
            last_location = $location.path();
            $location.path("/login");
        },
        back: function() {
            if (last_location != null && last_location != "login") {
                $location.path(last_location);
            } else {
                $location.path("/");
            }
        }
    };
} ]);

krusha.factory("interceptor", [ "$q", "loggedin", "redirect", "notifications", function($q, loggedin, redirect, notifications) {
    var rateLimitGone = null;
    var lastRateLimitNotificationShown = null;
    return {
        response: function(response) {
            return response;
        },
        responseError: function(response) {
            if (response.status === 401) {
                loggedin.setStatus(false);
                if (!("login" in response.data)) {
                    redirect.login();
                }
            }
            if (response.status === 429) {
                if (rateLimitGone === null || rateLimitGone < Date.parse(response.data.error.nextValidRequestDate) || lastRateLimitNotificationShown + 5e3 < Date.now()) {
                    rateLimitGone = Date.parse(response.data.error.nextValidRequestDate);
                    var timeTillNextRequest = Math.floor((rateLimitGone - Date.now()) / 1e3);
                    var minutes = Math.floor(timeTillNextRequest / 60);
                    var seconds = timeTillNextRequest - minutes * 60;
                    var message = "You made to many requests. You can make next request in ";
                    message += minutes > 0 ? minutes + " minutes and " : "";
                    message += seconds + " seconds.";
                    lastRateLimitNotificationShown = Date.now();
                    notifications.add(message, "danger", 5e3, true);
                }
            }
            return $q.reject(response);
        }
    };
} ]);

krusha.factory("helpers", function() {
    return {
        lastOpen: function(arr) {
            var keylist = [];
            for (var key in arr) {
                if (arr.hasOwnProperty(key)) keylist.push(key);
            }
            var last = Math.max.apply(Math, keylist);
            arr[last].status = true;
            return arr;
        }
    };
});

krusha.factory("parse", [ function() {
    var show_cache = {};
    var season_cache = {};
    var findShow = function(shows, showid) {
        if (show_cache.hasOwnProperty(showid)) {
            return show_cache[showid];
        } else {
            for (var i = 0, len = shows.length; i < len; i++) {
                if (shows[i].showid === showid) {
                    show_cache[showid] = i;
                    return i;
                }
            }
            return null;
        }
    };
    var findSeason = function(seasons, season_nr, show_index) {
        if (!season_cache.hasOwnProperty(show_index)) {
            season_cache[show_index] = {};
        }
        if (season_cache[show_index].hasOwnProperty(season_nr)) {
            return season_cache[show_index][season_nr];
        } else {
            for (var i = 0, len = seasons.length; i < len; i++) {
                if (parseInt(seasons[i].season) == parseInt(season_nr)) {
                    season_cache[show_index][season_nr] = i;
                    return i;
                }
            }
            return null;
        }
    };
    var removeUnnecessary = function(shows) {
        for (var i = shows.length - 1; i >= 0; i--) {
            if (shows[i].seasons.length === 0) {
                shows.splice(i, 1);
            }
        }
    };
    return {
        unwatched: function(data, shows) {
            data.episodes.forEach(function(episode) {
                var show_index = findShow(shows, episode.showid);
                var season_index = findSeason(shows[show_index].seasons, episode.season, show_index);
                if (season_index === null) {
                    shows[show_index].seasons.push({
                        season: episode.season,
                        episodes: []
                    });
                    season_index = findSeason(shows[show_index].seasons, episode.season, show_index);
                }
                shows[show_index].seasons[season_index].episodes.push(episode);
            });
            removeUnnecessary(shows);
            show_cache = {};
            season_cache = {};
        },
        watchedEpisode: function(shows, episode, season, show) {
            var show_index = shows.indexOf(show);
            var season_index = shows[show_index].seasons.indexOf(season);
            var episode_index = shows[show_index].seasons[season_index].episodes.indexOf(episode);
            shows[show_index].seasons[season_index].episodes.splice(episode_index, 1);
            if (shows[show_index].seasons[season_index].episodes.length === 0) {
                shows[show_index].seasons.splice(season_index, 1);
                if (shows[show_index].seasons.length === 0) {
                    shows.splice(show_index, 1);
                }
            }
        },
        watchedSeason: function(shows, season, show) {
            var show_index = shows.indexOf(show);
            var season_index = shows[show_index].seasons.indexOf(season);
            shows[show_index].seasons.splice(season_index, 1);
            if (shows[show_index].seasons.length === 0) {
                shows.splice(show_index, 1);
            }
        },
        watchedShow: function(shows, show) {
            var show_index = shows.indexOf(show);
            shows.splice(show_index, 1);
        }
    };
} ]);

krusha.factory("loggedin", [ "$rootScope", function($rootScope) {
    var loggedin = false;
    var user = null;
    var dateFormat = "yyyy-MM-dd";
    return {
        getStatus: function() {
            return loggedin;
        },
        setStatus: function(status) {
            loggedin = status;
            $rootScope.$broadcast("loggedin");
        },
        setUser: function(username) {
            user = username;
        },
        getUser: function() {
            return user;
        },
        getDateFormat: function() {
            return dateFormat;
        },
        setDateFormat: function(format) {
            if (format) dateFormat = format; else dateFormat = "yyyy-MM-dd";
        }
    };
} ]);

krusha.factory("notifications", [ "$rootScope", function($rootScope) {
    var notifications = [];
    return {
        add: function(message, bg_class, ttl, close, link) {
            if (typeof close === "undefined") {
                close = false;
            }
            if (typeof link === "undefined") {
                link = false;
            }
            notifications.push({
                message: message,
                "class": bg_class,
                ttl: ttl,
                close: close,
                link: link
            });
            $rootScope.$broadcast("notification", true);
        },
        pop: function() {
            var note_temp = notifications;
            notifications = [];
            return note_temp;
        }
    };
} ]);

krusha.factory("apiAuth", [ "$http", function($http) {
    return {
        login: function(username, password) {
            return $http.post("/api/login", {
                username: username,
                password: password
            });
        },
        logout: function() {
            return $http.get("/api/logout");
        },
        signup: function(username, password, captcha) {
            return $http.post("/api/signup", {
                username: username,
                password: password,
                captcha: captcha
            });
        },
        loginStatus: function() {
            return $http.get("/api/status");
        }
    };
} ]);

krusha.factory("apiImdb", [ "$http", function($http) {
    return {
        submitIMDbId: function(imdb_id, show_id) {
            return $http.post("/api/imdb", {
                imdb_id: imdb_id,
                showid: show_id
            });
        },
        getSubmittedIMDbIds: function() {
            return $http.get("/api/admin/imdb");
        },
        acceptSubmittedIMDbID: function(submission_id) {
            return $http.put("/api/admin/imdb/" + submission_id);
        }
    };
} ]);

krusha.factory("apiReddit", [ "$http", function($http) {
    return {
        subreddit: function(subreddit) {
            return $http.get("//www.reddit.com" + subreddit + "/hot.json?limit=5");
        },
        reddit5more: function(subreddit, after) {
            return $http.get("//www.reddit.com" + subreddit + "/hot.json?limit=5&after=" + after);
        },
        submitSubreddit: function(subreddit, show_id) {
            return $http.post("/api/subreddit", {
                subreddit: subreddit,
                showid: show_id
            });
        },
        getSubmittedSubreddits: function() {
            return $http.get("/api/admin/subreddit");
        },
        acceptSubmittedSubreddit: function(submission_id) {
            return $http.put("/api/admin/subreddit/" + submission_id);
        }
    };
} ]);

krusha.factory("apiSearch", [ "$http", "$q", "loggedin", function($http, $q, loggedin) {
    return {
        searchLocal: function(search_input) {
            var cache = !loggedin.getStatus();
            search_input = search_input.trim();
            if (search_input.length >= 2) {
                return $http.get("/api/search/" + search_input, {
                    cache: cache
                }).then(function(data) {
                    return data;
                }, function(err) {
                    return $q(function(resolve, reject) {
                        return reject(err);
                    });
                });
            } else {
                return $q(function(resolve, reject) {
                    return reject({
                        type: "error",
                        code: 400,
                        message: "Search query is too short."
                    });
                });
            }
        },
        searchRemote: function(search_input) {
            search_input = search_input.trim();
            if (search_input.length >= 3) {
                return $http.get("/api/search/" + search_input + "/remote", {
                    cache: true,
                    timeout: 1e4
                }).then(function(data) {
                    return data;
                }, function(err) {
                    return $q(function(resolve, reject) {
                        return reject(err);
                    });
                });
            } else {
                return $q(function(resolve, reject) {
                    return reject({
                        type: "error",
                        code: 400,
                        message: "Search query is too short."
                    });
                });
            }
        }
    };
} ]);

krusha.factory("apiSettings", [ "$http", function($http) {
    return {
        setEpisodeOffset: function(days, hours) {
            return $http.put("/api/profile/settings/episode-offset", {
                offset: {
                    days: days,
                    hours: hours
                }
            });
        },
        getProfile: function() {
            return $http.get("/api/profile");
        },
        setDateFormat: function(date_format) {
            return $http.put("/api/profile/settings/date-format", {
                date_format: date_format
            });
        }
    };
} ]);

krusha.factory("apiShow", [ "$http", function($http) {
    return {
        addShow: function(showid) {
            return $http.post("/api/show/", {
                showid: showid
            });
        },
        getShow: function(showid) {
            return $http.get("/api/show/" + showid);
        },
        getSeasons: function(showid) {
            return $http.get("/api/show/" + showid + "/season");
        },
        getEpisodes: function(showid, season_nr) {
            return $http.get("/api/show/" + showid + "/season/" + season_nr + "/episodes");
        },
        getTracked: function() {
            return $http.get("/api/track");
        },
        addTracked: function(showid) {
            return $http.post("/api/track", {
                showid: showid
            });
        },
        deleteTracked: function(showid) {
            return $http.delete("/api/track/" + showid);
        },
        watchedEpisode: function(episode_id) {
            return $http.post("/api/watched/episode", {
                episodeid: episode_id
            });
        },
        notWatchedEpisode: function(episode_id) {
            return $http.delete("/api/watched/episode/" + episode_id);
        },
        getUnwatched: function() {
            return $http.get("/api/unwatched");
        },
        getWatched: function() {
            return $http.get("/api/watched");
        },
        markSeasonWatched: function(showid, season_nr) {
            return $http.post("/api/watched/season", {
                showid: showid,
                season_nr: season_nr
            });
        },
        markShowWatched: function(showid) {
            return $http.post("/api/watched/show", {
                showid: showid
            });
        },
        markShowNotWatched: function(showid) {
            return $http.delete("/api/watched/show/" + showid);
        },
        markSeasonNotWatched: function(showid, season_nr) {
            return $http.delete("/api/watched/season/" + showid + "/" + season_nr);
        },
        getTodaysEpisodes: function() {
            return $http.get("/api/today");
        },
        getomdb: function(imdb_id) {
            return $http.get("//www.omdbapi.com/?r=json&i=" + imdb_id);
        },
        getUnwatchedShows: function() {
            return $http.get("/api/unwatched/shows");
        },
        getUnwatchedSeasons: function(showid) {
            return $http.get("/api/unwatched/shows/" + showid + "/seasons");
        },
        getUnwatchedEpisodes: function(showid, season) {
            return $http.get("/api/unwatched/shows/" + showid + "/seasons/" + season + "/episodes");
        },
        getWatchedShows: function() {
            return $http.get("/api/watched/shows");
        },
        getWatchedSeasons: function(showid) {
            return $http.get("/api/watched/shows/" + showid + "/seasons");
        },
        getWatchedEpisodes: function(showid, season) {
            return $http.get("/api/watched/shows/" + showid + "/seasons/" + season + "/episodes");
        }
    };
} ]);

krusha.controller("loginCtrl", [ "$scope", "$location", "apiAuth", "notifications", "redirect", "loggedin", function($scope, $location, apiAuth, notifications, redirect, loggedin) {
    $scope.$parent.title = "Login";
    $scope.alerts = [];
    var loggedin_func = function() {
        apiAuth.loginStatus().success(function() {
            $location.path("/");
        });
    };
    $scope.closeAlert = function(index) {
        $scope.alerts.splice(index, 1);
    };
    $scope.login_full = function(username, password) {
        apiAuth.login(username, password).success(function(data) {
            notifications.add("Welcome " + data.user + "!", "success", 5e3);
            loggedin.setUser(data.user);
            loggedin.setStatus(true);
            redirect.back();
        }).error(function(data, code) {
            if (code === 401) {
                $scope.alerts.push({
                    type: "danger",
                    msg: data.message
                });
            }
        });
    };
    loggedin_func();
} ]);

krusha.controller("navLoginCtrl", [ "$scope", "$location", "$modal", "redirect", "apiAuth", "loggedin", "notifications", function($scope, $location, $modal, redirect, apiAuth, loggedin, notifications) {
    $scope.loggedin = false;
    $scope.user = {
        name: null,
        id: null
    };
    var init = function() {
        apiAuth.loginStatus().success(function(data) {
            loggedin.setUser(data.user);
            loggedin.setDateFormat(data.dateFormat);
            loggedin.setStatus(true);
        }).error(function(err, status) {
            if (status == 401) {
                loggedin.setStatus(false);
            }
        });
    };
    $scope.loginButton = function() {
        redirect.login();
    };
    $scope.$on("loggedin", function() {
        $scope.loggedin = loggedin.getStatus();
        $scope.user.name = loggedin.getUser();
    });
    $scope.open = function() {
        $modal.open({
            templateUrl: "static/templates/loginmodal.html",
            size: "lg",
            controller: "ModalInstanceCtrl"
        });
    };
    $scope.logout = function() {
        apiAuth.logout().success(function() {
            notifications.add("Logout successful!", "warning", 5e3);
            loggedin.setStatus(false);
            loggedin.setDateFormat(false);
            $location.path("/");
        }).error(function() {
            notifications.add("Logout failed!", "danger", 5e3);
        });
    };
    init();
} ]);

krusha.controller("ModalInstanceCtrl", [ "$scope", "$modalInstance", "apiAuth", "notifications", "loggedin", function($scope, $modalInstance, apiAuth, notifications, loggedin) {
    $scope.alerts = [];
    $scope.cancel = function() {
        $modalInstance.dismiss("cancel");
    };
    $scope.login = function(username, password) {
        apiAuth.login(username, password).success(function(data) {
            notifications.add("Welcome " + data.user + "!", "success", 5e3);
            loggedin.setUser(data.user);
            loggedin.setDateFormat(data.dateFormat);
            loggedin.setStatus(true);
            $scope.cancel();
        }).error(function(data, code) {
            if (code === 401) {
                addAlert(data.message, "danger");
            }
        });
    };
    var addAlert = function(msg, type) {
        $scope.alerts.push({
            type: type,
            msg: msg
        });
    };
    $scope.closeAlert = function(index) {
        $scope.alerts.splice(index, 1);
    };
} ]);

krusha.controller("notificationsCtrl", [ "$scope", "notifications", function($scope, notifications) {
    $scope.notifications = {};
    var index = 0;
    var i;
    $scope.$on("notification", function() {
        notifications.pop().forEach(function(note) {
            i = index++;
            $scope.notifications[i] = note;
        });
    });
} ]);

krusha.controller("profileCtrl", [ "$scope", "$cookieStore", "apiSettings", "apiImdb", "apiReddit", "notifications", "loggedin", function($scope, $cookieStore, apiSettings, apiImdb, apiReddit, notifications, loggedin) {
    $scope.$parent.title = "Profile";
    $scope.admin = false;
    $scope.setOffsetSuccess = {
        value: "not"
    };
    $scope.changeDateFormatSuccess = {
        value: "not"
    };
    $scope.offsets = [];
    $scope.dateFormats = {
        "yyyy-MM-dd": "yyyy-MM-dd (2010-31-12)",
        "dd.MM.yyyy": "dd.MM.yyyy (31.12.2010)",
        "MM/dd/yyyy": "MM/dd/yyyy (12/31/2010)"
    };
    $scope.display = {
        reddit: true,
        imdb: true
    };
    if (typeof $cookieStore.get("display") !== "undefined") {
        $scope.display = $cookieStore.get("display");
    }
    $scope.dateFormat = "";
    var now = new Date();
    now.setHours(0);
    now.setMinutes(0);
    now.setSeconds(0);
    now.setMilliseconds(0);
    $scope.now = now;
    var getProfile = function() {
        apiSettings.getProfile().success(function(data) {
            $scope.username = data.user;
            $scope.total_shows = data.total_shows;
            $scope.total_episodes = data.total_episodes;
            $scope.admin = data.admin;
            $scope.offset = data.settings.episode_offset;
            computeOffset($scope.offset);
            $scope.dateFormat = data.settings.date_format;
        });
    };
    $scope.setOffset = function(offset) {
        apiSettings.setEpisodeOffset(parseInt(offset.days), parseInt(offset.hours)).success(function() {
            $scope.setOffsetSuccess.value = true;
        }).error(function() {
            $scope.setOffsetSuccess.value = false;
        });
    };
    var computeOffset = function(offset) {
        if (typeof offset !== "undefined") {
            var total_hours = offset.days * 24 + offset.hours;
            var hours = total_hours % 24;
            var days = (total_hours - hours) / 24;
            $scope.days = days;
            $scope.hours = hours;
            var dateDisplayed = new Date();
            dateDisplayed.setHours(0);
            dateDisplayed.setMinutes(0);
            dateDisplayed.setSeconds(0);
            dateDisplayed.setMilliseconds(0);
            dateDisplayed.setDate($scope.now.getDate() + days);
            dateDisplayed.setHours($scope.now.getHours() + hours);
            $scope.dateDisplayed = dateDisplayed;
        }
    };
    $scope.$watch("offset", computeOffset, true);
    $scope.getIMDbIds = function() {
        apiImdb.getSubmittedIMDbIds().success(function(data) {
            $scope.imdb_ids = data.imdb_ids;
        }).error(function(err, code) {
            if (code === 404) {
                $scope.imdb_ids = null;
            }
        });
    };
    $scope.acceptIMDbId = function(submission_id) {
        apiImdb.acceptSubmittedIMDbID(submission_id).success(function() {
            $scope.getIMDbIds();
        }).error(function(err, code) {
            if (code === 409) {
                notifications.add(err.message, "danger", 5e3);
            }
        });
    };
    $scope.getSubreddits = function() {
        apiReddit.getSubmittedSubreddits().success(function(data) {
            $scope.subreddits = data.subreddits;
        }).error(function(err, code) {
            if (code === 404) {
                $scope.subreddits = null;
            }
        });
    };
    $scope.acceptSub = function(submission_id) {
        apiReddit.acceptSubmittedSubreddit(submission_id).success(function() {
            $scope.getSubreddits();
        });
    };
    $scope.changeDateFormat = function(date_format) {
        apiSettings.setDateFormat(date_format).success(function() {
            $scope.changeDateFormatSuccess.value = true;
            loggedin.setDateFormat(date_format);
        });
    };
    $scope.changeDisplaySetting = function(display) {
        $cookieStore.put("display", display);
    };
    getProfile();
} ]);

krusha.controller("mainCtrl", [ "$scope", "$rootScope", "$location", "search_text", function($scope, $rootScope, $location, search_text) {
    $scope.getResults = function(search_input) {
        search_text.setText(search_input);
        if ($location.path() !== "/search") {
            $location.path("/search");
        } else {
            $rootScope.$broadcast("search_input");
        }
    };
} ]);

krusha.controller("searchCtrl", [ "$scope", "$location", "$rootScope", "apiSearch", "apiShow", "search_text", function($scope, $location, $rootScope, apiSearch, apiShow, search_text) {
    $scope.$parent.title = "Search Results";
    $scope.shows = [];
    $scope.shows_remote = [];
    var getResults = function() {
        var search_query = search_text.getText();
        if (search_query !== null && search_query.length >= 2) {
            $scope.shows = [];
            $scope.shows_remote = [];
            apiSearch.searchLocal(search_query).then(function(data) {
                $scope.shows = data.data.shows;
            }, function() {
                $scope.shows = [];
            });
            apiSearch.searchRemote(search_query).then(function(data) {
                $scope.shows_remote = data.data.shows;
            }, function() {
                $scope.shows_remote = [];
            });
        }
    };
    var compileSearch = function() {
        var result = $scope.shows;
        $scope.shows_remote.forEach(function(show) {
            var show_in_db = false;
            for (var i in result) {
                if (result.hasOwnProperty(i)) {
                    if (result[i].showid === show.showid) {
                        show_in_db = true;
                        break;
                    }
                }
            }
            if (!show_in_db) {
                result.push(show);
            }
        });
        $scope.result = result;
    };
    $scope.$watch("shows", compileSearch);
    $scope.$watch("shows_remote", compileSearch);
    $scope.mobileSearch = function(search_input) {
        search_text.setText(search_input);
        $rootScope.$broadcast("search_input");
    };
    $scope.getShow = function(show) {
        if (show.location === "local") {
            $location.path("/show/" + show.id);
        } else {
            apiShow.addShow(show.showid).success(function(data) {
                $location.path("/show/" + data.id);
            });
        }
    };
    $scope.clearSearch = function() {
        $scope.mobSearchText = "";
        $("#mobileSearch").focus();
    };
    $scope.$on("search_input", function() {
        getResults();
    });
    getResults();
} ]);

krusha.controller("showCtrl", [ "$scope", "$routeParams", "$cookies", "$cookieStore", "$timeout", "apiShow", "apiReddit", "apiImdb", "notifications", "loggedin", function($scope, $routeParams, $cookies, $cookieStore, $timeout, apiShow, apiReddit, apiImdb, notifications, loggedin) {
    $scope.show = {};
    $scope.seasons = {};
    $scope.tracked = null;
    $scope.reddit = [];
    $scope.showWatched = true;
    $scope.loggedin = loggedin.getStatus();
    $scope.submittedRedditText = false;
    $scope.submittedImdbId = false;
    $scope.dateFormat = loggedin.getDateFormat();
    $scope.active_season = 1;
    var reddit_info = {};
    $scope.dateFormat = loggedin.getDateFormat();
    var oneWeekAgo = new Date();
    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
    var today = new Date();
    $scope.display = {
        reddit: true,
        imdb: true
    };
    if (typeof $cookieStore.get("display") !== "undefined") {
        $scope.display = $cookieStore.get("display");
    }
    $scope.$on("loggedin", function() {
        $scope.loggedin = loggedin.getStatus();
        getShow(showid);
        $scope.getEpisodes(showid, $scope.active_season);
        updateShowWatched();
    });
    var updateShowWatched = function() {
        if ($cookies.showWatched !== undefined && $scope.loggedin === true) {
            $scope.showWatched = $cookies.showWatched === "true";
        }
    };
    var omdb_get = function(imdb_id) {
        apiShow.getomdb(imdb_id).success(function(data) {
            $scope.omdb = data;
        });
    };
    var reddit_get = function(subreddit) {
        apiReddit.subreddit(subreddit).success(function(data) {
            reddit_info.sub = subreddit;
            reddit_info.after = data.data.after;
            data.data.children.forEach(function(thread) {
                $scope.reddit.push(thread);
            });
        });
    };
    $scope.nextFive = function() {
        apiReddit.reddit5more(reddit_info.sub, reddit_info.after).success(function(data) {
            reddit_info.after = data.data.after;
            data.data.children.forEach(function(thread) {
                $scope.reddit.push(thread);
            });
        });
    };
    var getShow = function(show_id) {
        apiShow.getShow(show_id).success(function(data) {
            $scope.show = data;
            $scope.$parent.title = $scope.show.name;
            if ("tracked" in data) $scope.tracked = data.tracked; else $scope.tracked = null;
            if (data.subreddit && $scope.display.reddit) {
                reddit_get(data.subreddit);
            }
            if (data.imdbid && $scope.display.imdb) {
                omdb_get(data.imdbid);
            }
        }).error(function(json, code) {
            if (code === 404) {
                $scope.show.name = "Show not found";
            }
        });
    };
    var getSeasons = function(show_id, active_season) {
        apiShow.getSeasons(show_id).success(function(data) {
            $scope.seasons = data.seasons;
            if (typeof active_season === "undefined") {
                active_season = data.season - 1;
            } else {
                active_season--;
            }
            $scope.seasons[active_season].active = true;
            $scope.episodes = data.episodes;
            updateScrollOffset();
        });
    };
    $scope.getEpisodes = function(show_id, season_nr) {
        $scope.active_season = season_nr;
        apiShow.getEpisodes(show_id, season_nr).success(function(data) {
            $scope.episodes = data.episodes;
            $scope.seasons.find(function(season) {
                return season.active === true;
            }).active = false;
            $scope.seasons.find(function(season) {
                return season.season === data.season;
            }).active = true;
            updateScrollOffset();
            $scope.scrollToEpisodes();
        });
    };
    $scope.SaveShowWatched = function(showWatched) {
        $cookies.showWatched = showWatched;
        $scope.showWatched = showWatched;
        getNextUnwatchedSeason();
    };
    $scope.lessThanAWeek = function(airdate) {
        var airdate_parsed = new Date(Date.parse(airdate));
        return airdate_parsed >= oneWeekAgo && airdate_parsed <= today;
    };
    $scope.track = function(show, tracked) {
        if (!tracked) {
            apiShow.addTracked(show.id).success(function() {
                $scope.tracked = true;
                notifications.add("Added " + show.name + " to tracked shows.", "success", 5e3);
                getSeasons(show.id, $scope.active_season);
            });
        } else {
            apiShow.deleteTracked(show.id).success(function() {
                $scope.tracked = false;
                notifications.add("Removed " + show.name + " from tracked shows.", "danger", 5e3);
            });
        }
    };
    $scope.watchedEpisode = function(episode) {
        var season = $scope.seasons.find(function(season) {
            return season.active === true;
        });
        if (!episode.watched) {
            apiShow.watchedEpisode(episode.id).success(function() {
                episode.watched = true;
                season.watched_count++;
                getNextUnwatchedSeason();
            });
        } else {
            apiShow.notWatchedEpisode(episode.id).success(function() {
                episode.watched = false;
                season.watched_count--;
                getNextUnwatchedSeason();
            });
        }
    };
    $scope.submitSubreddit = function(reddit_url, show_id) {
        var subreddit = reddit_url.match(reddit_regex);
        apiReddit.submitSubreddit(subreddit[1], show_id).success(function() {
            $scope.submittedRedditText = subreddit[1];
        });
    };
    $scope.submitIMDB = function(imdb_url, show_id) {
        var imdb_id = imdb_url.match(imdb_regex);
        apiImdb.submitIMDbId(imdb_id[1], show_id).success(function() {
            $scope.submittedImdbId = imdb_id[1];
        });
    };
    var updateScrollOffset = function() {
        $timeout(updateOffset);
    };
    $scope.unwatchedSeasons = function() {
        if ($scope.tracked && $scope.showWatched === false) {
            for (var season in $scope.seasons) {
                if ($scope.seasons.hasOwnProperty(season)) {
                    if ($scope.seasons[season].episode_count > $scope.seasons[season].watched_count) {
                        return true;
                    }
                }
            }
            return false;
        }
        return true;
    };
    var getNextUnwatchedSeason = function() {
        if ($scope.showWatched !== true) {
            var nextUnwatchedSeason = false;
            for (var i = $scope.active_season - 1; i < $scope.seasons.length; i++) {
                if ($scope.seasons.hasOwnProperty(i)) {
                    if ($scope.seasons[i].episode_count > $scope.seasons[i].watched_count) {
                        nextUnwatchedSeason = i;
                        break;
                    }
                }
            }
            if (!nextUnwatchedSeason) {
                for (var j = $scope.active_season - 2; j >= 0; j--) {
                    if ($scope.seasons.hasOwnProperty(j)) {
                        if ($scope.seasons[j].episode_count > $scope.seasons[j].watched_count) {
                            nextUnwatchedSeason = j;
                            break;
                        }
                    }
                }
            }
            if (nextUnwatchedSeason > 0 || nextUnwatchedSeason === 0) {
                $scope.getEpisodes($scope.show.id, nextUnwatchedSeason + 1);
            }
        }
    };
    $scope.scrollToSeasons = function() {
        $(document.body).animate({
            scrollTop: $("#seasons").offset().top - 70
        }, 200);
    };
    $scope.scrollToEpisodes = function() {
        $(document.body).animate({
            scrollTop: $("#episodes").offset().top - 70
        }, 200);
    };
    var showid = $routeParams.id;
    getShow(showid);
    getSeasons(showid);
    updateShowWatched();
} ]);

krusha.controller("signupCtrl", [ "$scope", "$location", "apiAuth", "notifications", "loggedin", function($scope, $location, apiAuth, notifications, loggedin) {
    $scope.$parent.title = "Sign Up";
    $scope.alerts = [];
    var loggedin_func = function() {
        apiAuth.loginStatus().success(function() {
            $location.path("/");
        });
    };
    $scope.closeAlert = function(index) {
        $scope.alerts.splice(index, 1);
    };
    $scope.signup = function(username, password) {
        var captcha = grecaptcha.getResponse();
        if (captcha === "") {
            $scope.alerts.push({
                type: "danger",
                msg: "You need to complete the captcha."
            });
        } else {
            apiAuth.signup(username, password, captcha).success(function(data) {
                loggedin.setStatus(true);
                notifications.add("Welcome " + data.user + "!", "success", 5e3);
                $location.path("/");
            }).error(function(err) {
                grecaptcha.reset();
                $scope.alerts.push({
                    type: "danger",
                    msg: err.message
                });
            });
        }
    };
    loggedin_func();
} ]);

krusha.controller("todayCtrl", [ "$scope", "$filter", "$location", "apiShow", function($scope, $filter, $location, apiShow) {
    $scope.$parent.title = "New Episodes";
    $scope.stopClick = function(event) {
        event.stopPropagation();
    };
    var getTodaysEpisodes = function() {
        apiShow.getTodaysEpisodes().success(function(data) {
            $scope.todays_episodes = $filter("filter")(data.episodes, {
                age: 0
            }, true);
            $scope.tomorrows_episodes = $filter("filter")(data.episodes, {
                age: -1
            }, true);
            $scope.yesterdays_episodes = $filter("filter")(data.episodes, {
                age: 1
            }, true);
        });
    };
    $scope.changeLocation = function(showid) {
        $location.path("show/" + showid);
    };
    getTodaysEpisodes();
} ]);

krusha.controller("trackCtrl", [ "$scope", "apiShow", "notifications", function($scope, apiShow, notifications) {
    $scope.$parent.title = "Tracked Shows";
    var getTracked = function() {
        apiShow.getTracked().success(function(data) {
            $scope.shows = data.shows;
        }).error(function(err, status) {
            if (status === 404) {
                $scope.shows = null;
            }
        });
    };
    var doTrack = function(show) {
        apiShow.addTracked(show.id).success(function() {
            getTracked();
            notifications.add("You are now tracking " + show.name + " again.", "success", 1e4, true);
        });
    };
    $scope.doNotTrack = function(show) {
        apiShow.deleteTracked(show.id).success(function() {
            $scope.shows.splice($scope.shows.indexOf(show), 1);
            var undo = {
                link_function: function() {
                    doTrack(show);
                },
                text: "Undo"
            };
            notifications.add("Removed " + show.name + " from tracked shows.", "danger", 1e4, true, undo);
        });
    };
    $scope.orderByName = function(show) {
        var remove_the_regex = /(?:^the )?(.*)/i;
        return show.name.match(remove_the_regex)[1];
    };
    getTracked();
} ]);

krusha.controller("unwatchedCtrl", [ "$scope", "$filter", "apiShow", function($scope, $filter, apiShow) {
    $scope.$parent.title = "Unwatched Episodes";
    $scope.watched = false;
    var getUnwatchedShows = function() {
        apiShow.getUnwatchedShows().success(function(data) {
            $scope.shows = data.shows;
            $scope.shows[0].active = true;
            $scope.seasons = data.seasons;
            $scope.seasons[0].active = true;
            $scope.episodes = data.episodes;
        });
    };
    $scope.getUnwatchedSeasons = function(showid) {
        apiShow.getUnwatchedSeasons(showid).success(function(data) {
            var active_show = $scope.shows.find(function(show) {
                return show.id === showid;
            });
            $scope.shows.forEach(function(show) {
                show.active = false;
            });
            active_show.active = true;
            $scope.seasons = data.seasons;
            $scope.seasons[0].active = true;
            $scope.episodes = data.episodes;
        });
    };
    $scope.getUnwatchedEpisodes = function(showid, season_nr) {
        apiShow.getUnwatchedEpisodes(showid, season_nr).success(function(data) {
            var active_season = $scope.seasons.find(function(season) {
                return season.season === season_nr;
            });
            $scope.seasons.forEach(function(season) {
                season.active = false;
            });
            active_season.active = true;
            $scope.episodes = data.episodes;
        });
    };
    $scope.markEpisodeWatched = function(episode) {
        apiShow.watchedEpisode(episode.id).success(function() {
            $scope.episodes.splice($scope.episodes.indexOf(episode), 1);
            if ($scope.episodes.length === 0) {
                var season = $scope.seasons.find(function(season) {
                    return !!season.active;
                });
                $scope.seasons.splice($scope.seasons.indexOf(season), 1);
                var show = $scope.shows.find(function(show) {
                    return !!show.active;
                });
                if ($scope.seasons.length > 0) {
                    $scope.getUnwatchedEpisodes(show.id, $scope.seasons[0].season);
                } else {
                    $scope.shows.splice($scope.shows.indexOf(show), 1);
                    if ($scope.shows.length > 0) {
                        $scope.getUnwatchedSeasons($filter("orderByName")($scope.shows)[0].id);
                    }
                }
            }
        });
    };
    $scope.markSeasonWatched = function() {
        var season_index = $scope.seasons.findIndex(function(season) {
            return !!season.active;
        });
        var show_index = $scope.shows.findIndex(function(show) {
            return !!show.active;
        });
        var showid = $scope.shows[show_index].id;
        var season_nr = $scope.seasons[season_index].season;
        apiShow.markSeasonWatched(showid, season_nr).success(function() {
            $scope.seasons.splice(season_index, 1);
            if ($scope.seasons.length > 0) {
                $scope.getUnwatchedEpisodes(showid, $scope.seasons[0].season);
            } else {
                $scope.shows.splice(show_index, 1);
                if ($scope.shows.length > 0) {
                    $scope.getUnwatchedSeasons($filter("orderByName")($scope.shows)[0].id);
                }
            }
        });
    };
    $scope.markShowWatched = function() {
        var show_index = $scope.shows.findIndex(function(show) {
            return !!show.active;
        });
        var showid = $scope.shows[show_index].id;
        apiShow.markShowWatched(showid).success(function() {
            $scope.shows.splice(show_index, 1);
            if ($scope.shows.length > 0) {
                $scope.getUnwatchedSeasons($filter("orderByName")($scope.shows)[0].id);
            }
        });
    };
    getUnwatchedShows();
} ]);

krusha.controller("watchedCtrl", [ "$scope", "$filter", "apiShow", function($scope, $filter, apiShow) {
    $scope.$parent.title = "Watched Episodes";
    $scope.watched = true;
    var getWatchedShows = function() {
        apiShow.getWatchedShows().success(function(data) {
            $scope.shows = data.shows;
            $scope.shows[0].active = true;
            $scope.seasons = data.seasons;
            $scope.seasons[0].active = true;
            $scope.episodes = data.episodes;
        });
    };
    $scope.getWatchedSeasons = function(showid) {
        apiShow.getWatchedSeasons(showid).success(function(data) {
            var active_show = $scope.shows.find(function(show) {
                return show.id === showid;
            });
            $scope.shows.forEach(function(show) {
                show.active = false;
            });
            active_show.active = true;
            $scope.seasons = data.seasons;
            $scope.seasons[0].active = true;
            $scope.episodes = data.episodes;
        });
    };
    $scope.getWatchedEpisodes = function(showid, season_nr) {
        apiShow.getWatchedEpisodes(showid, season_nr).success(function(data) {
            var active_season = $scope.seasons.find(function(season) {
                return season.season === season_nr;
            });
            $scope.seasons.forEach(function(season) {
                season.active = false;
            });
            active_season.active = true;
            $scope.episodes = data.episodes;
        });
    };
    $scope.markEpisodeUnwatched = function(episode) {
        apiShow.notWatchedEpisode(episode.id).success(function() {
            $scope.episodes.splice($scope.episodes.indexOf(episode), 1);
            if ($scope.episodes.length === 0) {
                var season = $scope.seasons.find(function(season) {
                    return !!season.active;
                });
                $scope.seasons.splice($scope.seasons.indexOf(season), 1);
                var show = $scope.shows.find(function(show) {
                    return !!show.active;
                });
                if ($scope.seasons.length > 0) {
                    $scope.getWatchedEpisodes(show.id, $scope.seasons[0].season);
                } else {
                    $scope.shows.splice($scope.shows.indexOf(show), 1);
                    if ($scope.shows.length > 0) {
                        $scope.getWatchedSeasons($filter("orderByName")($scope.shows)[0].id);
                    }
                }
            }
        });
    };
    $scope.markSeasonNotWatched = function() {
        var season_index = $scope.seasons.findIndex(function(season) {
            return !!season.active;
        });
        var show_index = $scope.shows.findIndex(function(show) {
            return !!show.active;
        });
        var showid = $scope.shows[show_index].id;
        var season_nr = $scope.seasons[season_index].season;
        apiShow.markSeasonNotWatched(showid, season_nr).success(function() {
            $scope.seasons.splice(season_index, 1);
            if ($scope.seasons.length > 0) {
                $scope.getWatchedEpisodes(showid, $scope.seasons[0].season);
            } else {
                $scope.shows.splice(show_index, 1);
                if ($scope.shows.length > 0) {
                    $scope.getWatchedSeasons($filter("orderByName")($scope.shows)[0].id);
                }
            }
        });
    };
    $scope.markShowNotWatched = function() {
        var show_index = $scope.shows.findIndex(function(show) {
            return !!show.active;
        });
        var showid = $scope.shows[show_index].id;
        apiShow.markShowNotWatched(showid).success(function() {
            $scope.shows.splice(show_index, 1);
            if ($scope.shows.length > 0) {
                $scope.getWatchedSeasons($filter("orderByName")($scope.shows)[0].id);
            }
        });
    };
    getWatchedShows();
} ]);
//# sourceMappingURL=krusha.min.js.map