if (!Array.prototype.find) {
    Array.prototype.find = function(predicate) {
        if (this == null) {
            throw new TypeError("Array.prototype.find called on null or undefined");
        }
        if (typeof predicate !== "function") {
            throw new TypeError("predicate must be a function");
        }
        var list = Object(this);
        var length = list.length >>> 0;
        var thisArg = arguments[1];
        var value;
        for (var i = 0; i < length; i++) {
            value = list[i];
            if (predicate.call(thisArg, value, i, list)) {
                return value;
            }
        }
        return undefined;
    };
}

if (!Array.prototype.findIndex) {
    Array.prototype.findIndex = function(predicate) {
        if (this == null) {
            throw new TypeError("Array.prototype.find called on null or undefined");
        }
        if (typeof predicate !== "function") {
            throw new TypeError("predicate must be a function");
        }
        var list = Object(this);
        var length = list.length >>> 0;
        var thisArg = arguments[1];
        var value;
        for (var i = 0; i < length; i++) {
            value = list[i];
            if (predicate.call(thisArg, value, i, list)) {
                return i;
            }
        }
        return -1;
    };
}

function updateOffset() {
    var heightDifference = $(".shows .tab-pane.active").outerHeight() - $(".shows .col-md-12 .nav-pills").outerHeight();
    if (heightDifference > 0) {
        var scrollOffset = heightDifference + +$(".show > .col-xs-12").outerHeight();
        if ($(this).scrollTop() < scrollOffset) {
            $(".shows ul.nav").css("position", "fixed");
            $(".shows ul.nav").css("bottom", "");
        } else {
            $(".shows ul.nav").css("position", "absolute");
            $(".shows ul.nav").css("bottom", "0");
        }
    } else {
        $(".shows ul.nav").css("position", "static");
        $(".shows ul.nav").css("bottom", "");
    }
}

$(window).scroll(updateOffset);

var krusha = angular.module("krushaTV", [ "ngRoute", "ngAnimate", "ngCookies", "ngSanitize", "ui.bootstrap", "growlNotifications", "ui.bootstrap-slider" ]);

krusha.config([ "$routeProvider", "$httpProvider", "$compileProvider", "$locationProvider", function($routeProvider, $httpProvider, $compileProvider, $locationProvider) {
    $routeProvider.when("/", {
        templateUrl: "/static/templates/today.html",
        controller: "todayCtrl"
    }).when("/search", {
        templateUrl: "/static/templates/search.html",
        controller: "searchCtrl"
    }).when("/show/:id", {
        templateUrl: "/static/templates/show.html",
        controller: "showCtrl"
    }).when("/login", {
        templateUrl: "/static/templates/login.html",
        controller: "loginCtrl"
    }).when("/signup", {
        templateUrl: "/static/templates/signup.html",
        controller: "signupCtrl"
    }).when("/track", {
        templateUrl: "/static/templates/track.html",
        controller: "trackCtrl"
    }).when("/admin/reddit", {
        templateUrl: "/static/templates/admin/reddit.html",
        controller: "redditCtrl"
    }).when("/admin/imdb", {
        templateUrl: "/static/templates/admin/imdb.html",
        controller: "imdbCtrl"
    }).when("/profile", {
        templateUrl: "/static/templates/profile.html",
        controller: "profileCtrl"
    }).when("/unwatched", {
        templateUrl: "/static/templates/unwatched.html",
        controller: "unwatchedCtrl"
    }).when("/watched", {
        templateUrl: "/static/templates/watched.html",
        controller: "watchedCtrl"
    }).otherwise({
        redirectTo: "/"
    });
    $httpProvider.interceptors.push("interceptor");
    $compileProvider.debugInfoEnabled(true);
    $locationProvider.html5Mode(true);
} ]);

krusha.controller("notificationsCtrl", [ "$scope", "notifications", function($scope, notifications) {
    $scope.notifications = {};
    var index = 0;
    var i;
    $scope.$on("notification", function() {
        notifications.pop().forEach(function(note) {
            i = index++;
            $scope.notifications[i] = note;
        });
    });
} ]);

krusha.controller("navCtrl", [ function() {} ]);

krusha.controller("parentCtrl", [ "$scope", function($scope) {
    $scope.title = "";
} ]);

krusha.filter("orderByName", [ "$filter", function($filter) {
    var remove_the_regex = /(?:^the )?(.*)/i;
    var save_sort_by = "name";
    var remove_the = function(show) {
        return show[save_sort_by].match(remove_the_regex)[1];
    };
    return function(shows, sort_by) {
        save_sort_by = typeof sort_by !== "undefined" ? sort_by : "name";
        return $filter("orderBy")(shows, remove_the);
    };
} ]);

krusha.filter("formatEpisode", function() {
    var zeroPadding = function(n) {
        n = parseInt(n);
        if (n < 10) {
            return "0" + n.toString();
        } else {
            return n.toString();
        }
    };
    return function(episode, season) {
        episode = zeroPadding(episode);
        season = zeroPadding(season);
        return "S" + season + "E" + episode;
    };
});

krusha.filter("countUnwatched", function() {
    var countUnwatched = function(show) {
        return !!show.find(function(season) {
            if (season.episodes.find(function(episode) {
                return episode.watched === false;
            })) {
                return true;
            }
        });
    };
    return function(show, showWatched) {
        return showWatched ? true : countUnwatched(show);
    };
});

var reddit_regex = /^(?:http(?:s)?:\/\/)?(?:www\.)?(?:reddit\.com)?(\/r\/\w+)(?:[.?&/].*)?$/i;

var imdb_regex = /^(?:https?:\/\/)?(?:www.)?(?:imdb.com\/title\/)?(tt\d{7})(?:\/.*)?$/i;

krusha.directive("subreddit", function() {
    return {
        require: "ngModel",
        link: function(scope, elm, attrs, ctrl) {
            ctrl.$validators.subreddit = function(modelValue, viewValue) {
                if (ctrl.$isEmpty(modelValue)) {
                    return true;
                }
                if (reddit_regex.test(viewValue)) {
                    return true;
                }
                return false;
            };
        }
    };
});

krusha.directive("imdb", function() {
    return {
        require: "ngModel",
        link: function(scope, elm, attrs, ctrl) {
            ctrl.$validators.imdb = function(modelValue, viewValue) {
                if (ctrl.$isEmpty(modelValue)) {
                    return true;
                }
                if (imdb_regex.test(viewValue)) {
                    return true;
                }
                return false;
            };
        }
    };
});

krusha.directive("loadingspinner", [ "$http", function($http) {
    return {
        restrict: "E",
        link: function($scope, elm) {
            $scope.isLoading = function() {
                return $http.pendingRequests.length > 0;
            };
            $scope.$watch($scope.isLoading, function(v) {
                if (v) {
                    elm.show();
                } else {
                    elm.hide();
                }
            });
        },
        template: '<div class="spinner"><div class="bounce1"></div><div class="bounce2"></div><div class="bounce3"></div></div>'
    };
} ]);

krusha.directive("loadingcontent", [ "$http", function($http) {
    return {
        restrict: "A",
        link: function(scope, elm) {
            scope.isLoading = function() {
                return $http.pendingRequests.length > 0;
            };
            scope.$watch(scope.isLoading, function(v) {
                if (v) {
                    elm.hide();
                } else {
                    elm.show();
                }
            });
        }
    };
} ]);

krusha.directive("watched", [ "$cookies", "loggedin", function($cookies, loggedin) {
    var link = function($scope) {
        $scope.dateFormat = loggedin.getDateFormat();
        if ($cookies.oneAtATime === undefined) {
            $cookies.oneAtATime = true;
        }
        $scope.oneAtATime = $cookies.oneAtATime === "true";
        if ($scope.watched) {
            $scope.watchedText = "unwatched";
            $scope.notWatchedText = "watched";
        } else {
            $scope.watchedText = "watched";
            $scope.notWatchedText = "unwatched";
        }
        $scope.openAll = function(open) {
            if (open) $scope.oneAtATime = false;
            for (var key in $scope.shows) {
                if ($scope.shows.hasOwnProperty(key)) $scope.shows[key].status = open;
            }
        };
        $scope.SaveOneAtATime = function(oneAtATime) {
            $cookies.oneAtATime = oneAtATime;
        };
    };
    return {
        restrict: "E",
        scope: {
            shows: "=shows",
            markEpisodeWatched: "=episodeWatched",
            markSeasonWatched: "=seasonWatched",
            markShowWatched: "=showWatched",
            watched: "=watched"
        },
        link: link,
        templateUrl: "/static/templates/directives/watched.html"
    };
} ]);

krusha.directive("unwatched", [ "$timeout", "loggedin", function($timeout, loggedin) {
    var link = function($scope) {
        if (typeof $scope.shows === "undefined") $scope.shows = [];
        if (typeof $scope.seasons === "undefined") $scope.seasons = [];
        $scope.dateFormat = loggedin.getDateFormat();
        $scope.getActiveShow = function() {
            return $scope.shows.find(function(show) {
                return !!show.active;
            });
        };
        $scope.getActiveSeason = function() {
            return $scope.seasons.find(function(season) {
                return !!season.active;
            });
        };
        $scope.watched_text = $scope.watched ? "unwatched" : "watched";
        $scope.watched_text_cap = $scope.watched ? "Unwatched" : "Watched";
    };
    return {
        restrict: "E",
        templateUrl: "/static/templates/directives/unwatched.html",
        link: link,
        scope: {
            shows: "=shows",
            seasons: "=seasons",
            episodes: "=episodes",
            getSeasons: "=getSeasons",
            getEpisodes: "=getEpisodes",
            markEpisodeWatched: "=markEpisodeWatched",
            markSeasonWatched: "=markSeasonWatched",
            markShowWatched: "=markShowWatched",
            watched: "=watched"
        }
    };
} ]);

krusha.directive("success", [ "$timeout", function($timeout) {
    var link = function($scope, element) {
        var timeout_promise = null;
        $scope.$watch("successHandler", function(newVal, oldVal) {
            if (newVal !== oldVal && newVal !== "not") {
                $timeout.cancel(timeout_promise);
                element.fadeIn(100);
                $scope.success = $scope.successHandler;
                $scope.successHandler = "not";
                timeout_promise = $timeout(function() {
                    element.fadeOut();
                }, $scope.timeout);
            }
        }, true);
    };
    return {
        restrict: "E",
        scope: {
            timeout: "@timeout",
            successHandler: "=success"
        },
        template: '<span class="text-success glyphicon glyphicon-ok" ng-if="success === true"></span><span class="text-danger" ng-if="success === false">Error</span>',
        link: link
    };
} ]);

krusha.service("search_text", [ function() {
    var search = null;
    return {
        getText: function() {
            return search;
        },
        setText: function(value) {
            search = value;
        }
    };
} ]);

krusha.factory("redirect", [ "$location", function($location) {
    var last_location = null;
    return {
        login: function() {
            last_location = $location.path();
            $location.path("/login");
        },
        back: function() {
            if (last_location != null && last_location != "login") {
                $location.path(last_location);
            } else {
                $location.path("/");
            }
        }
    };
} ]);

krusha.factory("interceptor", [ "$q", "loggedin", "redirect", function($q, loggedin, redirect) {
    return {
        response: function(response) {
            return response;
        },
        responseError: function(response) {
            if (response.status === 401) {
                loggedin.setStatus(false);
                if (!("login" in response.data)) {
                    redirect.login();
                }
            }
            return $q.reject(response);
        }
    };
} ]);

krusha.factory("helpers", function() {
    return {
        lastOpen: function(arr) {
            var keylist = [];
            for (var key in arr) {
                if (arr.hasOwnProperty(key)) keylist.push(key);
            }
            var last = Math.max.apply(Math, keylist);
            arr[last].status = true;
            return arr;
        }
    };
});

krusha.factory("notifications", [ "$rootScope", function($rootScope) {
    var notifications = [];
    return {
        add: function(message, bg_class, ttl) {
            notifications.push({
                message: message,
                "class": bg_class,
                ttl: ttl
            });
            $rootScope.$broadcast("notification", true);
        },
        pop: function() {
            var note_temp = notifications;
            notifications = [];
            return note_temp;
        }
    };
} ]);

krusha.factory("loggedin", [ "$rootScope", function($rootScope) {
    var loggedin = false;
    var user = null;
    var dateFormat = "yyyy-MM-dd";
    return {
        getStatus: function() {
            return loggedin;
        },
        setStatus: function(status) {
            loggedin = status;
            $rootScope.$broadcast("loggedin");
        },
        setUser: function(username) {
            user = username;
        },
        getUser: function() {
            return user;
        },
        getDateFormat: function() {
            return dateFormat;
        },
        setDateFormat: function(format) {
            if (format) dateFormat = format; else dateFormat = "yyyy-MM-dd";
        }
    };
} ]);

krusha.factory("parse", [ function() {
    var show_cache = {};
    var season_cache = {};
    var findShow = function(shows, showid) {
        if (show_cache.hasOwnProperty(showid)) {
            return show_cache[showid];
        } else {
            for (var i = 0, len = shows.length; i < len; i++) {
                if (shows[i].showid === showid) {
                    show_cache[showid] = i;
                    return i;
                }
            }
            return null;
        }
    };
    var findSeason = function(seasons, season_nr, show_index) {
        if (!season_cache.hasOwnProperty(show_index)) {
            season_cache[show_index] = {};
        }
        if (season_cache[show_index].hasOwnProperty(season_nr)) {
            return season_cache[show_index][season_nr];
        } else {
            for (var i = 0, len = seasons.length; i < len; i++) {
                if (parseInt(seasons[i].season) == parseInt(season_nr)) {
                    season_cache[show_index][season_nr] = i;
                    return i;
                }
            }
            return null;
        }
    };
    var removeUnnecessary = function(shows) {
        for (var i = shows.length - 1; i >= 0; i--) {
            if (shows[i].seasons.length === 0) {
                shows.splice(i, 1);
            }
        }
    };
    return {
        unwatched: function(data, shows) {
            data.episodes.forEach(function(episode) {
                var show_index = findShow(shows, episode.showid);
                var season_index = findSeason(shows[show_index].seasons, episode.season, show_index);
                if (season_index === null) {
                    shows[show_index].seasons.push({
                        season: episode.season,
                        episodes: []
                    });
                    season_index = findSeason(shows[show_index].seasons, episode.season, show_index);
                }
                shows[show_index].seasons[season_index].episodes.push(episode);
            });
            removeUnnecessary(shows);
            show_cache = {};
            season_cache = {};
        },
        watchedEpisode: function(shows, episode, season, show) {
            var show_index = shows.indexOf(show);
            var season_index = shows[show_index].seasons.indexOf(season);
            var episode_index = shows[show_index].seasons[season_index].episodes.indexOf(episode);
            shows[show_index].seasons[season_index].episodes.splice(episode_index, 1);
            if (shows[show_index].seasons[season_index].episodes.length === 0) {
                shows[show_index].seasons.splice(season_index, 1);
                if (shows[show_index].seasons.length === 0) {
                    shows.splice(show_index, 1);
                }
            }
        },
        watchedSeason: function(shows, season, show) {
            var show_index = shows.indexOf(show);
            var season_index = shows[show_index].seasons.indexOf(season);
            shows[show_index].seasons.splice(season_index, 1);
            if (shows[show_index].seasons.length === 0) {
                shows.splice(show_index, 1);
            }
        },
        watchedShow: function(shows, show) {
            var show_index = shows.indexOf(show);
            shows.splice(show_index, 1);
        }
    };
} ]);

krusha.factory("apiAuth", [ "$http", function($http) {
    return {
        login: function(username, password) {
            return $http.post("/api/login", {
                username: username,
                password: password
            });
        },
        logout: function() {
            return $http.get("/api/logout");
        },
        signup: function(username, password) {
            return $http.post("/api/signup", {
                username: username,
                password: password
            });
        },
        loginStatus: function() {
            return $http.get("/api/status");
        }
    };
} ]);

krusha.factory("apiImdb", [ "$http", function($http) {
    return {
        submitIMDbId: function(imdb_id, show_id) {
            return $http.post("/api/imdb", {
                imdb_id: imdb_id,
                showid: show_id
            });
        },
        getSubmittedIMDbIds: function() {
            return $http.get("/api/admin/imdb");
        },
        acceptSubmittedIMDbID: function(submission_id) {
            return $http.put("/api/admin/imdb/" + submission_id);
        }
    };
} ]);

krusha.factory("apiReddit", [ "$http", function($http) {
    return {
        subreddit: function(subreddit) {
            return $http.get("//www.reddit.com" + subreddit + "/hot.json?limit=5");
        },
        reddit5more: function(subreddit, after) {
            return $http.get("//www.reddit.com" + subreddit + "/hot.json?limit=5&after=" + after);
        },
        submitSubreddit: function(subreddit, show_id) {
            return $http.post("/api/subreddit", {
                subreddit: subreddit,
                showid: show_id
            });
        },
        getSubmittedSubreddits: function() {
            return $http.get("/api/admin/subreddit");
        },
        acceptSubmittedSubreddit: function(submission_id) {
            return $http.put("/api/admin/subreddit/" + submission_id);
        }
    };
} ]);

krusha.factory("apiSearch", [ "$http", "$q", function($http, $q) {
    return {
        searchLocal: function(search_input) {
            if (search_input.length >= 2) {
                return $http.get("/api/search/" + search_input, {
                    cache: true
                }).then(function(data) {
                    return data;
                });
            } else {
                var deferred = $q.defer();
                deferred.reject(false);
                return deferred.promise;
            }
        },
        searchRemote: function(search_input) {
            search_input = search_input.trim();
            if (search_input.length >= 3) {
                return $http.get("/api/search/" + search_input + "/remote", {
                    cache: true,
                    timeout: 1e4
                }).then(function(data) {
                    return data;
                });
            } else {
                var deferred = $q.defer();
                deferred.reject(false);
                return deferred.promise;
            }
        }
    };
} ]);

krusha.factory("apiSettings", [ "$http", function($http) {
    return {
        setEpisodeOffset: function(days, hours) {
            return $http.put("/api/profile/settings/episode-offset", {
                offset: {
                    days: days,
                    hours: hours
                }
            });
        },
        getProfile: function() {
            return $http.get("/api/profile");
        },
        setDateFormat: function(date_format) {
            return $http.put("/api/profile/settings/date-format", {
                date_format: date_format
            });
        }
    };
} ]);

krusha.factory("apiShow", [ "$http", function($http) {
    return {
        addShow: function(showid) {
            return $http.post("/api/show/", {
                showid: showid
            });
        },
        getShow: function(showid) {
            return $http.get("/api/show/" + showid);
        },
        getEpisodes: function(showid) {
            return $http.get("/api/show/" + showid + "/episodes");
        },
        getTracked: function() {
            return $http.get("/api/track");
        },
        addTracked: function(showid) {
            return $http.post("/api/track", {
                showid: showid
            });
        },
        deleteTracked: function(showid) {
            return $http.delete("/api/track/" + showid);
        },
        watchedEpisode: function(episode_id) {
            return $http.post("/api/watched/episode", {
                episodeid: episode_id
            });
        },
        notWatchedEpisode: function(episode_id) {
            return $http.delete("/api/watched/episode/" + episode_id);
        },
        getUnwatched: function() {
            return $http.get("/api/unwatched");
        },
        getWatched: function() {
            return $http.get("/api/watched");
        },
        markSeasonWatched: function(showid, season_nr) {
            return $http.post("/api/watched/season", {
                showid: showid,
                season_nr: season_nr
            });
        },
        markShowWatched: function(showid) {
            return $http.post("/api/watched/show", {
                showid: showid
            });
        },
        markShowNotWatched: function(showid) {
            return $http.delete("/api/watched/show/" + showid);
        },
        markSeasonNotWatched: function(showid, season_nr) {
            return $http.delete("/api/watched/season/" + showid + "/" + season_nr);
        },
        getTodaysEpisodes: function() {
            return $http.get("/api/today");
        },
        getomdb: function(imdb_id) {
            return $http.get("//www.omdbapi.com/?r=json&i=" + imdb_id);
        },
        getUnwatchedShows: function() {
            return $http.get("/api/unwatched/shows");
        },
        getUnwatchedSeasons: function(showid) {
            return $http.get("/api/unwatched/shows/" + showid + "/seasons");
        },
        getUnwatchedEpisodes: function(showid, season) {
            return $http.get("/api/unwatched/shows/" + showid + "/seasons/" + season + "/episodes");
        },
        getWatchedShows: function() {
            return $http.get("/api/watched/shows");
        },
        getWatchedSeasons: function(showid) {
            return $http.get("/api/watched/shows/" + showid + "/seasons");
        },
        getWatchedEpisodes: function(showid, season) {
            return $http.get("/api/watched/shows/" + showid + "/seasons/" + season + "/episodes");
        }
    };
} ]);

krusha.controller("loginCtrl", [ "$scope", "$location", "apiAuth", "notifications", "redirect", "loggedin", function($scope, $location, apiAuth, notifications, redirect, loggedin) {
    $scope.$parent.title = "Login";
    $scope.alerts = [];
    var loggedin_func = function() {
        apiAuth.loginStatus().success(function() {
            $location.path("/");
        });
    };
    $scope.closeAlert = function(index) {
        $scope.alerts.splice(index, 1);
    };
    $scope.login_full = function(username, password) {
        apiAuth.login(username, password).success(function(data) {
            notifications.add("Welcome " + data.user + "!", "success", 5e3);
            loggedin.setUser(data.user);
            loggedin.setStatus(true);
            redirect.back();
        }).error(function(data, code) {
            if (code === 401) {
                $scope.alerts.push({
                    type: "danger",
                    msg: data.message
                });
            }
        });
    };
    loggedin_func();
} ]);

krusha.controller("navLoginCtrl", [ "$scope", "$location", "$modal", "redirect", "apiAuth", "loggedin", "notifications", function($scope, $location, $modal, redirect, apiAuth, loggedin, notifications) {
    $scope.loggedin = false;
    $scope.user = {
        name: null,
        id: null
    };
    var init = function() {
        apiAuth.loginStatus().success(function(data) {
            loggedin.setUser(data.user);
            loggedin.setDateFormat(data.dateFormat);
            loggedin.setStatus(true);
        }).error(function(err, status) {
            if (status == 401) {
                loggedin.setStatus(false);
            }
        });
    };
    $scope.loginButton = function() {
        redirect.login();
    };
    $scope.$on("loggedin", function() {
        $scope.loggedin = loggedin.getStatus();
        $scope.user.name = loggedin.getUser();
    });
    $scope.open = function() {
        $modal.open({
            templateUrl: "static/templates/loginmodal.html",
            size: "lg",
            controller: "ModalInstanceCtrl"
        });
    };
    $scope.logout = function() {
        apiAuth.logout().success(function() {
            notifications.add("Logout successful!", "warning", 5e3);
            loggedin.setStatus(false);
            loggedin.setDateFormat(false);
            $location.path("/");
        }).error(function() {
            notifications.add("Logout failed!", "danger", 5e3);
        });
    };
    init();
} ]);

krusha.controller("ModalInstanceCtrl", [ "$scope", "$modalInstance", "apiAuth", "notifications", "loggedin", function($scope, $modalInstance, apiAuth, notifications, loggedin) {
    $scope.alerts = [];
    $scope.cancel = function() {
        $modalInstance.dismiss("cancel");
    };
    $scope.login = function(username, password) {
        apiAuth.login(username, password).success(function(data) {
            notifications.add("Welcome " + data.user + "!", "success", 5e3);
            loggedin.setUser(data.user);
            loggedin.setDateFormat(data.dateFormat);
            loggedin.setStatus(true);
            $scope.cancel();
        }).error(function(data, code) {
            if (code === 401) {
                addAlert(data.message, "danger");
            }
        });
    };
    var addAlert = function(msg, type) {
        $scope.alerts.push({
            type: type,
            msg: msg
        });
    };
    $scope.closeAlert = function(index) {
        $scope.alerts.splice(index, 1);
    };
} ]);

krusha.controller("profileCtrl", [ "$scope", "apiSettings", "apiImdb", "apiReddit", "notifications", "loggedin", function($scope, apiSettings, apiImdb, apiReddit, notifications, loggedin) {
    $scope.$parent.title = "Profile";
    $scope.username = null;
    $scope.total_shows = null;
    $scope.total_episodes = null;
    $scope.admin = false;
    $scope.setOffsetSuccess = {
        value: "not"
    };
    $scope.changeDateFormatSuccess = {
        value: "not"
    };
    $scope.offsets = [];
    $scope.dateFormats = {
        "yyyy-MM-dd": "yyyy-MM-dd (2010-31-12)",
        "dd.MM.yyyy": "dd.MM.yyyy (31.12.2010)",
        "MM/dd/yyyy": "MM/dd/yyyy (12/31/2010)"
    };
    $scope.dateFormat = "";
    var now = new Date();
    now.setHours(0);
    now.setMinutes(0);
    now.setSeconds(0);
    now.setMilliseconds(0);
    $scope.now = now;
    var getProfile = function() {
        apiSettings.getProfile().success(function(data) {
            $scope.username = data.user;
            $scope.total_shows = data.total_shows;
            $scope.total_episodes = data.total_episodes;
            $scope.admin = data.admin;
            $scope.offset = data.settings.episode_offset;
            $scope.computeOffset($scope.offset);
            $scope.dateFormat = data.settings.date_format;
        });
    };
    $scope.setOffset = function(days, hours) {
        apiSettings.setEpisodeOffset(parseInt(days), parseInt(hours)).success(function() {
            $scope.setOffsetSuccess.value = true;
        }).error(function() {
            $scope.setOffsetSuccess.value = false;
        });
    };
    $scope.computeOffset = function(offset) {
        var total_hours = offset.days * 24 + offset.hours;
        var hours = total_hours % 24;
        var days = (total_hours - hours) / 24;
        $scope.days = days;
        $scope.hours = hours;
        var dateDisplayed = new Date();
        dateDisplayed.setHours(0);
        dateDisplayed.setMinutes(0);
        dateDisplayed.setSeconds(0);
        dateDisplayed.setMilliseconds(0);
        dateDisplayed.setDate($scope.now.getDate() + days);
        dateDisplayed.setHours($scope.now.getHours() + hours);
        $scope.dateDisplayed = dateDisplayed;
    };
    $scope.getIMDbIds = function() {
        apiImdb.getSubmittedIMDbIds().success(function(data) {
            $scope.imdb_ids = data.imdb_ids;
        }).error(function(err, code) {
            if (code === 404) {
                $scope.imdb_ids = null;
            }
        });
    };
    $scope.acceptIMDbId = function(submission_id) {
        apiImdb.acceptSubmittedIMDbID(submission_id).success(function() {
            $scope.getIMDbIds();
        }).error(function(err, code) {
            if (code === 409) {
                notifications.add(err.message, "danger", 5e3);
            }
        });
    };
    $scope.getSubreddits = function() {
        apiReddit.getSubmittedSubreddits().success(function(data) {
            $scope.subreddits = data.subreddits;
        }).error(function(err, code) {
            if (code === 404) {
                $scope.subreddits = null;
            }
        });
    };
    $scope.acceptSub = function(submission_id) {
        apiReddit.acceptSubmittedSubreddit(submission_id).success(function() {
            $scope.getSubreddits();
        });
    };
    $scope.changeDateFormat = function(date_format) {
        apiSettings.setDateFormat(date_format).success(function() {
            $scope.changeDateFormatSuccess.value = true;
            loggedin.setDateFormat(date_format);
        });
    };
    getProfile();
} ]);

krusha.controller("mainCtrl", [ "$scope", "$rootScope", "$location", "search_text", function($scope, $rootScope, $location, search_text) {
    $scope.getResults = function(search_input) {
        search_text.setText(search_input);
        if ($location.path() !== "/search") {
            $location.path("/search");
        } else {
            $rootScope.$broadcast("search_input");
        }
    };
} ]);

krusha.controller("searchCtrl", [ "$scope", "$location", "$rootScope", "apiSearch", "apiShow", "search_text", function($scope, $location, $rootScope, apiSearch, apiShow, search_text) {
    $scope.$parent.title = "Search Results";
    $scope.shows = [];
    $scope.shows_remote = [];
    var getResults = function() {
        var search_query = search_text.getText();
        search_text.setText(null);
        if (search_query !== null && search_query.length >= 2) {
            apiSearch.searchLocal(search_query).then(function(res) {
                $scope.shows = res.data.shows;
            });
            apiSearch.searchRemote(search_query).then(function(res) {
                $scope.shows_remote = res.data.shows;
            });
        }
    };
    var compileSearch = function() {
        var result = $scope.shows;
        $scope.shows_remote.forEach(function(show) {
            var show_in_db = false;
            for (var i in result) {
                if (result.hasOwnProperty(i)) {
                    if (result[i].showid === show.showid) {
                        show_in_db = true;
                        break;
                    }
                }
            }
            if (!show_in_db) {
                result.push(show);
            }
        });
        $scope.result = result;
    };
    $scope.$watch("shows", compileSearch);
    $scope.$watch("shows_remote", compileSearch);
    $scope.mobileSearch = function(search_input) {
        search_text.setText(search_input);
        $rootScope.$broadcast("search_input");
    };
    $scope.getShow = function(show) {
        if (show.location === "local") {
            $location.path("/show/" + show.id);
        } else {
            apiShow.addShow(show.showid).success(function(data) {
                $location.path("/show/" + data.id);
            });
        }
    };
    $scope.$on("search_input", function() {
        getResults();
    });
    getResults();
} ]);

krusha.controller("showCtrl", [ "$scope", "$routeParams", "$cookies", "$filter", "$timeout", "apiShow", "apiReddit", "apiImdb", "helpers", "notifications", "loggedin", function($scope, $routeParams, $cookies, $filter, $timeout, apiShow, apiReddit, apiImdb, helpers, notifications, loggedin) {
    $scope.show = {};
    $scope.seasons = {};
    $scope.tracked = null;
    $scope.reddit = [];
    $scope.showWatched = true;
    $scope.loggedin = loggedin.getStatus();
    $scope.submittedRedditText = false;
    $scope.submittedImdbId = false;
    $scope.dateFormat = loggedin.getDateFormat();
    var reddit_info = {};
    var oneWeekAgo = new Date();
    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
    var today = new Date();
    if ($cookies.oneAtATime === undefined) {
        $cookies.oneAtATime = true;
    }
    $scope.oneAtATime = $cookies.oneAtATime === "true";
    $scope.$on("loggedin", function() {
        $scope.loggedin = loggedin.getStatus();
        getShow(showid);
        getEpisodes(showid);
        updateShowWatched();
    });
    var updateShowWatched = function() {
        if ($cookies.showWatched !== undefined && $scope.loggedin === true) {
            $scope.showWatched = $cookies.showWatched === "true";
        }
    };
    var omdb_get = function(imdb_id) {
        apiShow.getomdb(imdb_id).success(function(data) {
            $scope.omdb = data;
        });
    };
    var reddit_get = function(subreddit) {
        apiReddit.subreddit(subreddit).success(function(data) {
            reddit_info.sub = subreddit;
            reddit_info.after = data.data.after;
            data.data.children.forEach(function(thread) {
                $scope.reddit.push(thread);
            });
        });
    };
    $scope.nextFive = function() {
        apiReddit.reddit5more(reddit_info.sub, reddit_info.after).success(function(data) {
            reddit_info.after = data.data.after;
            data.data.children.forEach(function(thread) {
                $scope.reddit.push(thread);
            });
        });
    };
    var getShow = function(show_id) {
        apiShow.getShow(show_id).success(function(data) {
            $scope.show = data;
            $scope.$parent.title = $scope.show.name;
            if ("tracked" in data) $scope.tracked = data.tracked; else $scope.tracked = null;
            if (data.subreddit) {
                reddit_get(data.subreddit);
            }
            if (data.imdbid) {
                omdb_get(data.imdbid);
            }
        }).error(function(json, code) {
            if (code === 404) {
                $scope.show.name = "Show not found";
            }
        });
    };
    var getEpisodes = function(show_id) {
        apiShow.getEpisodes(show_id).success(function(data) {
            $scope.seasons = [];
            for (var season in data.seasons) {
                if (data.seasons.hasOwnProperty(season)) $scope.seasons.push({
                    season: parseInt(season),
                    episodes: data.seasons[season].episodes,
                    status: false
                });
            }
            $scope.seasons = $filter("orderBy")($scope.seasons, "season");
            if ($scope.seasons.length > 0) {
                $scope.seasons[$scope.seasons.length - 1].status = true;
            }
        });
    };
    $scope.openAll = function(open) {
        if (open) $scope.oneAtATime = false;
        for (var key in $scope.seasons) {
            if ($scope.seasons.hasOwnProperty(key)) $scope.seasons[key].status = open;
        }
    };
    $scope.SaveOneAtATime = function(oneAtATime) {
        $cookies.oneAtATime = oneAtATime;
    };
    $scope.SaveShowWatched = function(showWatched) {
        $cookies.showWatched = showWatched;
        $scope.showWatched = showWatched;
    };
    $scope.lessThanAWeek = function(airdate) {
        var airdate_parsed = new Date(Date.parse(airdate));
        return airdate_parsed >= oneWeekAgo && airdate_parsed <= today;
    };
    $scope.track = function(show) {
        apiShow.addTracked(show.id).success(function() {
            $scope.tracked = true;
            notifications.add("Added " + show.name + " to tracked shows.", "success", 5e3);
        });
    };
    $scope.untrack = function(show) {
        apiShow.deleteTracked(show.id).success(function() {
            $scope.tracked = false;
            notifications.add("Removed " + show.name + " from tracked shows.", "danger", 5e3);
        });
    };
    $scope.showSeasons = function(episodes, showWatched) {
        if (showWatched === true) {
            return true;
        } else {
            var notWatched = 0;
            episodes.episodes.forEach(function(episode) {
                if (episode.watched !== true) {
                    notWatched++;
                }
            });
            return notWatched !== 0;
        }
    };
    $scope.watchedEpisode = function(episode) {
        apiShow.watchedEpisode(episode.id).success(function() {
            episode.watched = true;
        });
    };
    $scope.notWatchedEpisode = function(episode) {
        apiShow.notWatchedEpisode(episode.id).success(function() {
            episode.watched = false;
        });
    };
    $scope.submitSubreddit = function(reddit_url, show_id) {
        var subreddit = reddit_url.match(reddit_regex);
        apiReddit.submitSubreddit(subreddit[1], show_id).success(function() {
            $scope.submittedRedditText = subreddit[1];
        });
    };
    $scope.submitIMDB = function(imdb_url, show_id) {
        var imdb_id = imdb_url.match(imdb_regex);
        apiImdb.submitIMDbId(imdb_id[1], show_id).success(function() {
            $scope.submittedImdbId = imdb_id[1];
        });
    };
    $scope.updateOffset = function() {
        $timeout(updateOffset);
    };
    var showid = $routeParams.id;
    getShow(showid);
    getEpisodes(showid);
    updateShowWatched();
} ]);

krusha.controller("signupCtrl", [ "$scope", "$location", "apiAuth", "notifications", "loggedin", function($scope, $location, apiAuth, notifications, loggedin) {
    $scope.$parent.title = "Sign Up";
    $scope.alerts = [];
    var loggedin_func = function() {
        apiAuth.loginStatus().success(function() {
            $location.path("/");
        });
    };
    $scope.closeAlert = function(index) {
        $scope.alerts.splice(index, 1);
    };
    $scope.signup = function(username, password) {
        apiAuth.signup(username, password).success(function(data) {
            loggedin.setStatus(true);
            notifications.add("Welcome " + data.user + "!", "success", 5e3);
            $location.path("/");
        }).error(function(err) {
            $scope.alerts.push({
                type: "danger",
                msg: err.message
            });
        });
    };
    loggedin_func();
} ]);

krusha.controller("todayCtrl", [ "$scope", "$filter", "$location", "apiShow", function($scope, $filter, $location, apiShow) {
    $scope.$parent.title = "New Episodes";
    var getTodaysEpisodes = function() {
        apiShow.getTodaysEpisodes().success(function(data) {
            $scope.todays_episodes = $filter("filter")(data.episodes, {
                age: 0
            }, true);
            $scope.tomorrows_episodes = $filter("filter")(data.episodes, {
                age: -1
            }, true);
            $scope.yesterdays_episodes = $filter("filter")(data.episodes, {
                age: 1
            }, true);
        });
    };
    $scope.changeLocation = function(showid) {
        $location.path("show/" + showid);
    };
    getTodaysEpisodes();
} ]);

krusha.controller("trackCtrl", [ "$scope", "apiShow", function($scope, apiShow) {
    $scope.$parent.title = "Tracked Shows";
    var getTracked = function() {
        apiShow.getTracked().success(function(data) {
            $scope.shows = data.shows;
        }).error(function(err, status) {
            if (status === 404) {
                $scope.shows = null;
            }
        });
    };
    $scope.doNotTrack = function(show) {
        apiShow.deleteTracked(show.id).success(function() {
            $scope.shows.splice($scope.shows.indexOf(show), 1);
        });
    };
    $scope.orderByName = function(show) {
        var remove_the_regex = /(?:^the )?(.*)/i;
        return show.name.match(remove_the_regex)[1];
    };
    getTracked();
} ]);

krusha.controller("unwatchedCtrl", [ "$scope", "$filter", "apiShow", function($scope, $filter, apiShow) {
    $scope.$parent.title = "Unwatched Episodes";
    $scope.watched = false;
    var getUnwatchedShows = function() {
        apiShow.getUnwatchedShows().success(function(data) {
            $scope.shows = data.shows;
            $scope.shows[0].active = true;
            $scope.seasons = data.seasons;
            $scope.seasons[0].active = true;
            $scope.episodes = data.episodes;
        });
    };
    $scope.getUnwatchedSeasons = function(showid) {
        apiShow.getUnwatchedSeasons(showid).success(function(data) {
            var active_show = $scope.shows.find(function(show) {
                return show.id === showid;
            });
            $scope.shows.forEach(function(show) {
                show.active = false;
            });
            active_show.active = true;
            $scope.seasons = data.seasons;
            $scope.seasons[0].active = true;
            $scope.episodes = data.episodes;
        });
    };
    $scope.getUnwatchedEpisodes = function(showid, season_nr) {
        apiShow.getUnwatchedEpisodes(showid, season_nr).success(function(data) {
            var active_season = $scope.seasons.find(function(season) {
                return season.season === season_nr;
            });
            $scope.seasons.forEach(function(season) {
                season.active = false;
            });
            active_season.active = true;
            $scope.episodes = data.episodes;
        });
    };
    $scope.markEpisodeWatched = function(episode) {
        apiShow.watchedEpisode(episode.id).success(function() {
            $scope.episodes.splice($scope.episodes.indexOf(episode), 1);
            if ($scope.episodes.length === 0) {
                var season = $scope.seasons.find(function(season) {
                    return !!season.active;
                });
                $scope.seasons.splice($scope.seasons.indexOf(season), 1);
                var show = $scope.shows.find(function(show) {
                    return !!show.active;
                });
                if ($scope.seasons.length > 0) {
                    $scope.getUnwatchedEpisodes(show.id, $scope.seasons[0].season);
                } else {
                    $scope.shows.splice($scope.shows.indexOf(show), 1);
                    if ($scope.shows.length > 0) {
                        $scope.getUnwatchedSeasons($filter("orderByName")($scope.shows)[0].id);
                    }
                }
            }
        });
    };
    $scope.markSeasonWatched = function() {
        var season_index = $scope.seasons.findIndex(function(season) {
            return !!season.active;
        });
        var show_index = $scope.shows.findIndex(function(show) {
            return !!show.active;
        });
        var showid = $scope.shows[show_index].id;
        var season_nr = $scope.seasons[season_index].season;
        apiShow.markSeasonWatched(showid, season_nr).success(function() {
            $scope.seasons.splice(season_index, 1);
            if ($scope.seasons.length > 0) {
                $scope.getUnwatchedEpisodes(showid, $scope.seasons[0].season);
            } else {
                $scope.shows.splice(show_index, 1);
                if ($scope.shows.length > 0) {
                    $scope.getUnwatchedSeasons($filter("orderByName")($scope.shows)[0].id);
                }
            }
        });
    };
    $scope.markShowWatched = function() {
        var show_index = $scope.shows.findIndex(function(show) {
            return !!show.active;
        });
        var showid = $scope.shows[show_index].id;
        apiShow.markShowWatched(showid).success(function() {
            $scope.shows.splice(show_index, 1);
            if ($scope.shows.length > 0) {
                $scope.getUnwatchedSeasons($filter("orderByName")($scope.shows)[0].id);
            }
        });
    };
    getUnwatchedShows();
} ]);

krusha.controller("watchedCtrl", [ "$scope", "$filter", "apiShow", function($scope, $filter, apiShow) {
    $scope.$parent.title = "Watched Episodes";
    $scope.watched = true;
    var getWatchedShows = function() {
        apiShow.getWatchedShows().success(function(data) {
            $scope.shows = data.shows;
            $scope.shows[0].active = true;
            $scope.seasons = data.seasons;
            $scope.seasons[0].active = true;
            $scope.episodes = data.episodes;
        });
    };
    $scope.getWatchedSeasons = function(showid) {
        apiShow.getWatchedSeasons(showid).success(function(data) {
            var active_show = $scope.shows.find(function(show) {
                return show.id === showid;
            });
            $scope.shows.forEach(function(show) {
                show.active = false;
            });
            active_show.active = true;
            $scope.seasons = data.seasons;
            $scope.seasons[0].active = true;
            $scope.episodes = data.episodes;
        });
    };
    $scope.getWatchedEpisodes = function(showid, season_nr) {
        apiShow.getWatchedEpisodes(showid, season_nr).success(function(data) {
            var active_season = $scope.seasons.find(function(season) {
                return season.season === season_nr;
            });
            $scope.seasons.forEach(function(season) {
                season.active = false;
            });
            active_season.active = true;
            $scope.episodes = data.episodes;
        });
    };
    $scope.markEpisodeUnwatched = function(episode) {
        apiShow.notWatchedEpisode(episode.id).success(function() {
            $scope.episodes.splice($scope.episodes.indexOf(episode), 1);
            if ($scope.episodes.length === 0) {
                var season = $scope.seasons.find(function(season) {
                    return !!season.active;
                });
                $scope.seasons.splice($scope.seasons.indexOf(season), 1);
                var show = $scope.shows.find(function(show) {
                    return !!show.active;
                });
                if ($scope.seasons.length > 0) {
                    $scope.getWatchedEpisodes(show.id, $scope.seasons[0].season);
                } else {
                    $scope.shows.splice($scope.shows.indexOf(show), 1);
                    if ($scope.shows.length > 0) {
                        $scope.getWatchedSeasons($filter("orderByName")($scope.shows)[0].id);
                    }
                }
            }
        });
    };
    $scope.markSeasonNotWatched = function() {
        var season_index = $scope.seasons.findIndex(function(season) {
            return !!season.active;
        });
        var show_index = $scope.shows.findIndex(function(show) {
            return !!show.active;
        });
        var showid = $scope.shows[show_index].id;
        var season_nr = $scope.seasons[season_index].season;
        apiShow.markSeasonNotWatched(showid, season_nr).success(function() {
            $scope.seasons.splice(season_index, 1);
            if ($scope.seasons.length > 0) {
                $scope.getWatchedEpisodes(showid, $scope.seasons[0].season);
            } else {
                $scope.shows.splice(show_index, 1);
                if ($scope.shows.length > 0) {
                    $scope.getWatchedSeasons($filter("orderByName")($scope.shows)[0].id);
                }
            }
        });
    };
    $scope.markShowNotWatched = function() {
        var show_index = $scope.shows.findIndex(function(show) {
            return !!show.active;
        });
        var showid = $scope.shows[show_index].id;
        apiShow.markShowNotWatched(showid).success(function() {
            $scope.shows.splice(show_index, 1);
            if ($scope.shows.length > 0) {
                $scope.getWatchedSeasons($filter("orderByName")($scope.shows)[0].id);
            }
        });
    };
    getWatchedShows();
} ]);
//# sourceMappingURL=krusha.min.js.map